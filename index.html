<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.94.1" /><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://kuangdangli.github.io/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kuangdangli.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://kuangdangli.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kuangdangli.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://kuangdangli.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://kuangdangli.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://kuangdangli.github.io/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="My New Hugo Site" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://kuangdangli.github.io/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="My New Hugo Site"/>
<meta name="twitter:description" content=""/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "My New Hugo Site",
  "url": "https://kuangdangli.github.io/",
  "description": "",
  "thumbnailUrl": "https://kuangdangli.github.io/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kuangdangli.github.io/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="first-entry"> 
  <header class="entry-header">
    <h2>浅析Context
    </h2>
  </header>
  <section class="entry-content">
    <p>Context 是什么 Context 单词直译为上下文、背景、语境等，在 React 中此功能主要用于为组件树中的一系列节点共享信息及其更新，提供“上下文”。
何时使用Context 要为组件树中一系列节点提供全局信息例如用户信息、主题等信息时可以使用 Context，避免使用 props 时的层层嵌套传递。
API  React.createContext const myContext = React.createContext(defaultValue)   返回一个 Context 对象，其值由在组件树中离订阅此对象的节点最近的可匹配的 Provider 决定，只有当匹配不到对应 Provider 时，其值为 defaultValue。
 Context.Provider &lt;myContext.Provider value={/* 某个值 */}&gt; &lt;/myContext.Provider&gt;   每个 Context对象都会返回一个 Provider React 组件，组件树中被&lt;myContext.Provider&gt; 标签包裹的子组件都可订阅此 Context。
Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。
当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。从 Provider 到其内部 consumer 组件的传播不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件跳过更新的情况下也能更新。
  React.useContext
const contextValue = React....</p>
  </section>
  <footer class="entry-footer"><span title='2022-09-17 20:37:12 +0800 CST'>September 17, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 浅析Context" href="https://kuangdangli.github.io/post/%E6%B5%85%E6%9E%90context/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>浅析useReducer
    </h2>
  </header>
  <section class="entry-content">
    <p>useReducer 是什么 const [state, dispatch] = useReducer(reducer, state) useState 的替代方案。接收一个reducer 方法和 state ，返回当前的 state 及与其配套的 dispatch 方法。dispatch 通过与 reducer 配合来修改 state并刷新页面。在 state 逻辑较复杂且包含多个子值，或者修改前后的 state 相互依赖时， 使用 useReducer 是一个更方便的选择。
useReducer 的使用 state  指定初始state  const [state, dispatch] = useReducer(reducer, {n:1}) 将 state 作为 useReducer 的第二个参数直接传入。
惰性初始化  function init(initialArg) {  return {count:initialArg} } const [state, dispatch] = useReducer(reducer, initialArg, init) useReducer 接收三个参数，其中第三个参数为 state 的初始化函数，第二个参数为初始化函数的参数。
reducer function reducer(state,action){  switch(action.type){  case &#34;add&#34;:  return {n:state....</p>
  </section>
  <footer class="entry-footer"><span title='2022-09-16 21:01:34 +0800 CST'>September 16, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 浅析useReducer" href="https://kuangdangli.github.io/post/%E6%B5%85%E6%9E%90usereducer/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>浅析useState
    </h2>
  </header>
  <section class="entry-content">
    <p>useState是什么 useState 是 React 的一个基础API，用来管理函数组件的 state。
const [state,setState] = useState(initialState) useState 返回一个 state 和一个更新 state 的函数。
初次渲染时，state 与 initialState 值相同。
setState 用于更新 state，并且通知 React 进行一次重新渲染。
 setState(newValue) 重新渲染中的 state 将会是最新的 state。
简单实现useState 以下为完整代码
let _state = []; let index = 0; function simpleUseState(initialValue) {  let currentIndex = index;  _state[currentIndex] = _state[currentIndex] === undefined ? initialValue : _state[currentIndex];  function setState(newValue){  _state[currentIndex] = newValue;  render()//这步为重新渲染，需要将index的值归零  }  index &#43;= 1;  return [_state[currentIndex],setState] } 几点要点：...</p>
  </section>
  <footer class="entry-footer"><span title='2022-09-08 22:03:46 +0800 CST'>September 8, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 浅析useState" href="https://kuangdangli.github.io/post/%E6%B5%85%E6%9E%90usestate/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>类组件生命周期
    </h2>
  </header>
  <section class="entry-content">
    <p>组件的生命周期 生命周期是指组件再运行过程中特定的阶段执行的方法。
组件生命周期图谱见下图:下文将分别介绍一下常见的生命周期。
constructor(props) 调用时间:
在 React 组件挂载之前，会调用它的构造函数。实现构造函数时，应在其他语句之前调用 super(props)。否则会出现bug。
用途：
在 React 中，constructor仅用于以下两种情况：
 通过给 this.state赋值对象来初始化内部 state。 为事件处理函数绑定实例。  如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。
注意，不要在 constructor 中调用 setState。同样地，不要在其它方法中直接为 this.state 赋值，你应该调用 this.setState。另外，请避免将 props 的值复制给 state，你可以使用 this.props来读取它的值。
shouldComponentUpdate(nextProps, nextState) 调用时间:
当 props 和 state 发生变化时，shouldComponentUpdate() 会在渲染执行前被调用。返回值默认为 true。首次渲染或使用 forceUpdate时不会调用该方法。
用途:
使用 this.props与 nextProps 以及 this.state 与 nextState进行比较，返回 true 和 false 来通知 React 是否要更新。如果 shouldComponentUpdate() 返回 false，则不会调用 render()。
不建议使用该方法进行手动比较，内置的 pureComponent 是更为推荐的选项。 pureComponent 会对 props 和 state 进行浅层比较，并减少了条过必要更新的可能性。...</p>
  </section>
  <footer class="entry-footer"><span title='2022-08-27 17:07:06 +0800 CST'>August 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 类组件生命周期" href="https://kuangdangli.github.io/post/react/%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>初识组件
    </h2>
  </header>
  <section class="entry-content">
    <p>组件的概念 组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。
组件与元素的区别 元素是一个React元素，而组件是一个返回React元素的函数；元素的名字一般以小写字母开头，而组件的第一个字母通常大写。
//定义一个简单的组件 const Div = ()=&gt; &lt;div className=&#39;hello&#39;&gt;hello World&lt;/div&gt; //定义一个简单的元素 const div = &lt;div className=&#39;hello&#39;&gt;hello World&lt;/div&gt; 组件的种类 组件分为函数组件和类组件。
//函数组件 function Welcome(props) {  return &lt;h1&gt;hello,{{props.name}}&lt;/h1&gt; } //使用方法 &lt;Welcome name=&#39;frank&#39;/&gt; //函数组件 class Welcome extends React.Component{  render(){  return &lt;h1&gt;hello,{{this.props.name}}&lt;/h1&gt;  } } //使用方法 &lt;Welcome name=&#39;frank&#39;/&gt; JSX标签的翻译逻辑:
&lt;div/ &gt;会被翻译成c(&#39;div&#39;);
&lt;Welcome /&gt;会被翻译为React.createElement(Welcome);
React.createElement():
如果传入一个字符串‘div’，则会创建一个div;
如果传入一个函数，则会调用该函数，获取其返回值;
如果传入一个类，则会new类(执行constructor)，获取一个组件对象，然后调用render方法，获取其返回值。
props 当React元素为用户自定义组件时，它会将JSX所接收的属性(attributes)以及子组件(children)转换为单个对象传递给子组件，这个对象被称为&#34;props&#34;。
例如，下面这段代码会在页面上渲染 “Hello, React”：
function Welcome(props){  return &lt;h1&gt;hello,{{props....</p>
  </section>
  <footer class="entry-footer"><span title='2022-08-27 10:46:57 +0800 CST'>August 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 初识组件" href="https://kuangdangli.github.io/post/react/%E5%88%9D%E8%AF%86%E7%BB%84%E4%BB%B6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>JSX
    </h2>
  </header>
  <section class="entry-content">
    <p>JSX JSX是一种标签语法，它的形式很容易让人联想到模板，但它具有JavaScript的全部功能，能同时写出标记与逻辑用来生成React元素。
const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;//一段简单的JSX代码 JSX的本质 Babel 会把 JSX 转译成一个名为 React.createElement() 的函数。
以下两种示例代码完全等效：
const element = (  &lt;h1 className=&#34;greeting&#34;&gt;  Hello, world!  &lt;/h1&gt; ); const element = React.createElement(  &#39;h1&#39;,  {className: &#39;greeting&#39;},  &#39;Hello, world!&#39; ); React.createElement() 实际上创建了一个这样的对象：
// 注意：这是简化过的结构 const element = {  type: &#39;h1&#39;,  props: {  className: &#39;greeting&#39;,  children: &#39;Hello, world!&#39;  } }; 这些对象被称为 “React 元素”。它们描述了开发者希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。...</p>
  </section>
  <footer class="entry-footer"><span title='2022-08-25 21:22:37 +0800 CST'>August 25, 2022</span></footer>
  <a class="entry-link" aria-label="post link to JSX" href="https://kuangdangli.github.io/post/react/jsx/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>初识React
    </h2>
  </header>
  <section class="entry-content">
    <p>基础API介绍 正常情况下，React项目需要同时引入React、ReactDOM两个库才能正常运行。 React用来创建React元素，ReactDOM用来渲染。
const App = React.createElement(&#39;div&#39;,{className=&#39;red&#39;},n) // React.createElement(  type,  [props],  [...children] ) React.createElement创建并返回指定类型的新 React 元素。其中的类型参数既可以是标签名字符串（如 ‘div’ 或 ‘span’），也可以是 React 组件 类型 （class 组件或函数组件），或是 React fragment 类型。属性参数可以用来设置类名或绑定事件等。第三个参数接受其它数据。
ReactDOM.render(App,root) //render(element, container[, callback]) 在提供的 container 里渲染一个 React 元素，并返回对该组件的引用（或者针对无状态组件返回 null）。
如果 React 元素之前已经在 container 里渲染过，这将会对其执行更新操作，并仅会在必要时改变 DOM 以映射最新的 React 元素。
如果提供了可选的回调函数，该回调将在组件被渲染或更新之后被执行。
注意：
在 React 18 中，render 函数已被 createRoot 函数所取代。
使用基础API 用往常的思路来构建一个简单的&#43;1按钮。
const React = window.React//CDN引入的React会挂载在全局变量上 const ReactDOM = window.ReactDOM  let n = 0;  const App = React....</p>
  </section>
  <footer class="entry-footer"><span title='2022-08-25 10:55:47 +0800 CST'>August 25, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 初识React" href="https://kuangdangli.github.io/post/react/%E5%88%9D%E8%AF%86react/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>引入React
    </h2>
  </header>
  <section class="entry-content">
    <p>React是什么 React（也称为 React.js 或 ReactJS）是一个免费的开放源代码前端 JavaScript工具库，用于基于 UI 组件构建用户界面。它由 Meta（前身为 Facebook）和一个由个人开发者和公司组成的社群维护。
如何引入React  从CDN引入React 从类似BootCDN的网站获取到React、ReactDOM这两个库的链接，使用HTML的script标签将其引入到项目中。  &lt;script src=&#34;https://cdn.bootcdn.net/ajax/libs/react/18.2.0/umd/react.production.min.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;https://cdn.bootcdn.net/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js&#34;&gt;&lt;/script&gt; //注意两个库引入的顺序 一般存在cjs和umd两个版本。cjs全称CommonJS，是Node.js支持的模块规范。umd是同一模块定义，兼容各种模块规范(含浏览器)。理论上优先使用umd，同时支持Node.js和浏览器。
 通过webpack引入React
  使用create-react-app create-react-app，在React中起到的作用和Vue@cli在Vue中作用差不多，方便开发者快速创建项目。下面是使用create-react-app的步骤
  yarn global add create-react-app//全局安装create-react-app create-react-app xxx//在当前目录下创建名为xxx的React项目 cd xxx yarn start//进入项目，开启预览 </p>
  </section>
  <footer class="entry-footer"><span title='2022-08-23 21:59:24 +0800 CST'>August 23, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 引入React" href="https://kuangdangli.github.io/post/react/%E5%BC%95%E5%85%A5react/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Vue Reactivity
    </h2>
  </header>
  <section class="entry-content">
    <p>浅析Vue数据响应式 Vue.js 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，开发者对视图的修改，不会直接操作 DOM，而是通过修改数据。Vue利用Object.defineProperty将data对象的property改造成getter、setter，实现对data的监听和代理，在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。
下面通过代码来简单还原一下Vue数据响应。
let myData = {n:0} let data = proxy({ data:myData }) function proxy({data}){  let value = data.n  Object.defineProperty(data, &#39;n&#39;, {  get(){  return value  },  set(newValue){  if(newValue&lt;0)return  value = newValue  }//使用get、set定义伪属性n，覆盖掉对象上原始n。此后，myData对象上的n属性值的查看、修改都会经过自定义的函数，通过函数可以屏蔽掉需求外的操纵。这就达成了对data的监听。  })   const obj = {}  Object.defineProperty(obj, &#39;n&#39;, {  get(){  return data.n  },  set(value){  if(value&lt;0)return  data....</p>
  </section>
  <footer class="entry-footer"><span title='2022-08-07 21:47:06 +0800 CST'>August 7, 2022</span></footer>
  <a class="entry-link" aria-label="post link to Vue Reactivity" href="https://kuangdangli.github.io/post/vue-reactivity/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>SyncModifier
    </h2>
  </header>
  <section class="entry-content">
    <p>sync修饰符 子组件尝试改变一个prop属性值并将其同步到父组件时，开发者可以使用sync修饰符。 代码实例
Vue.component(&#34;Child&#34;,{  template: ` &lt;div class=&#34;child&#34;&gt; {{money}} &lt;button @click=&#34;$emit(&#39;update:money&#39;, money-100)&#34;&gt; &lt;span&gt;花钱&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; `,  props: [&#34;money&#34;] }) new Vue({  components: { Child: Child },  template:` &lt;div class=&#34;app&#34;&gt; App.vue 我现在有 {{total}} &lt;hr&gt; &lt;Child :money.sync=&#34;total&#34;/&gt; &lt;/div&gt; `,  data() {  return { total: 10000 };  } }) 子组件注册一个点击事件update:money，传出参数money-100，父组件使用.sync修饰符监听事件，并拿到子组件传出的参数并赋值给子组件的外部属性money。
//.sync修饰符相当于封装了如下操作 &lt;Child :money=&#34;total&#34; v-on:update-money=&#34;total = $event&#34;/&gt; </p>
  </section>
  <footer class="entry-footer"><span title='2022-08-07 21:19:12 +0800 CST'>August 7, 2022</span></footer>
  <a class="entry-link" aria-label="post link to SyncModifier" href="https://kuangdangli.github.io/post/syncmodifier/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://kuangdangli.github.io/page/2/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://kuangdangli.github.io/">My New Hugo Site</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
